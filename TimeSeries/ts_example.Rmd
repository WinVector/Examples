---
title: "ts_example"
output: github_document
---

R packages re-doing of [our nested model time series example](https://github.com/WinVector/Examples/blob/main/TimeSeries/nested_model_example.ipynb).


```{r, results='hide', message=FALSE, warning=FALSE}
# http://fable.tidyverts.org
library(fable)
library(tsibble)
library(tsibbledata)
library(lubridate)
library(dplyr)
library(ggplot2)
library(forecast)
library(jsonlite)
```

## The problem

We want to fit a time series with both durable and transient external regressors.

First let's show the generating parameters we are attempting to recover.

```{r}
model_specification <- fromJSON("generating_params.json")

model_specification
```

What we hope is to find `b_x_dur ~ b_z` and `b_x_imp ~ b_x`.

The generating and modeling lags specify translate into ARIMA terms as `p = 2, i = 0`. We take our own  advice from [A Time Series Apologia](https://github.com/WinVector/Examples/blob/main/TS/TS_example.md) and pick `q = p`. So in ARIMAX terms we try fitting a `pdq(2, 0, 2)` system.

We don't have any way to specify the nature of external regressors, with act as transient effects in the "regression with ARIMA residuals" formulation favored by the fable and forecast packages. This will lead to a degredation in fit quality and an inability to properly estimate `b_z` (as we can't specify the for of the effect we believe it has in the data).

## Fitting with external regressors using the fable package

General Fable formulation:

<code>
(1 - &phi;<sub>1</sub> B - ... - &phi;<sub>p</sub> B<sup>p</sup>)(1 - B)<sup>d</sup> y<sub>t</sub> = c + (1 - &theta;<sub>1</sub> B - ... - &theta;<sub>q</sub> B<sup>q</sup>) &epsilon;<sub>t</sub>
</code>

where <code>c = mean(1 - &phi;<sub>1</sub> - ... - &phi;<sub>p</sub>)</code>.

In our `pdq(2, 0, 2)` case this specializes to:

<code>
(1 - &phi;<sub>1</sub> B -  &phi;<sub>2</sub> B<sup>2</sup>)</sup> y<sub>t</sub> = c + (1 - &theta;<sub>1</sub> B - &theta;<sub>2</sub> B<sup>2</sup>) &epsilon;<sub>t</sub>
</code>

And knowing this is "regression with ARIMA residuals" when we add the external regressors this should be:

<code>
(1 - &phi;<sub>1</sub> B -  &phi;<sub>2</sub> B<sup>2</sup>)</sup> (y<sub>t</sub> - &beta;<sub>0</sub> - &beta;<sub>x</sub> x - &beta;<sub>z</sub> z) = c + (1 - &theta;<sub>1</sub> B - &theta;<sub>2</sub> B<sup>2</sup>) &epsilon;<sub>t</sub>
</code>

Given the `pdq(2, 0, 2)` specification, the modeling system then fits for <code>&phi;, &beta;, &theta;</code>. Note: I agree with the Prophet authors that the user has to be involved in specifying `pdq(2, 0, 2)`. Many auto-ARIMA systems seem to silently fail in presence of external regressors. Also, noramlly we don't have to care so much about model structure- as we are protected from that by calling `predict()` or `forecast()`. However, in this case we are very concerned if model structure will or will not allow us to express what we think the external regressors actually do (i.e. model structure).

This is what we meant about the chosen package specifying the modeling recurrence equations (i.e. taking that choice out of our hands). We can specify modeling the total, but not unobserved sub-populations of the system.

Frankly ARIMAX/SARIMAX appears to be a false path for business modelers. Time series research didn't actually stop at or actually consolidate on this terminology. Instead, transfer function methods and other more further developed systems are studied. Roughly: the scientific community is well served by ARIMAX. The research community moved on from ARIMAX. And, the business community *wishes* ARIMAX was in fact the dominant method, as it is the dominant software offered.

An odd point in this direction is: ARIMA prediction of tides. In fact tides are formed by external regressors: the gravitational attraction of the sun and moon. However just giving the ARIMA the exact periodicities of these regressors is enough for it to model the entire system *without* those inputs.


```{r}
# https://otexts.com/fpp3/regarima.html
d_train <- read.csv('d_train.csv', stringsAsFactors = FALSE)
d_test <- read.csv('d_test.csv', stringsAsFactors = FALSE)

fable_model <- (
  d_train %>%
    tsibble(index=time_tick) %>%
    model(
      ARIMA(y ~ 
              1  # turn off must specify constant warning
            + z_0   # external regressor (can also use xreg(z_0))
            + x_0   # external regressor (can also use xreg(x_0))
            + pdq(2, 0, 2)   # AR=MA=2, I=0
            + PDQ(0, 0, 0)   # turn off seasonality (help(ARIMA))
            )
    )
)
coef(fable_model)

```

Notice we recovered good estimates of the autoregressive terms `b_auto` (`ar1`, `ar2`), transient external effect coefficient `b_x` (`x_0`). We did not get a good estimate of the durable external effect coefficient `z_0` (`b_z`), so we did not infer how changes in this variable affect results. 

We would be able to forecast, as the auto-regressive terms dominate. We would not be able to plan, as we don't have a good estimate of `z_0` (`b_z`).

```{r}
model_specification
```


```{r}
preds <-  (
  fable_model %>%
    forecast(new_data=tsibble(d_test, index=time_tick)) 
)
d_test['fable ARIMAX prediction'] = preds['.mean']

# Rsquared
sse <- sum((d_test[['y']] - d_test[['fable ARIMAX prediction']])**2)
sey <- sum((d_test[['y']] - mean(d_test[['y']]))**2)
rsq <- 1 - sse/sey
# RMSE
rmse <- sqrt(mean((d_test[['y']] - d_test[['fable ARIMAX prediction']])**2))

(
  ggplot(
    data=d_test,
    mapping=aes(x=time_tick)
  )
  + geom_step(mapping=aes(y=`fable ARIMAX prediction`), direction='mid', color='blue')
  + geom_point(mapping=aes(y=y, shape=as.character(x_0)), size=2)
  + guides(shape = guide_legend(reverse=TRUE))
  + ggtitle(paste0("fable package on held out data, rmse: ", 
    sprintf('%.2f', rmse), ', rsq: ', sprintf('%.2f', rsq)))
) 
```




## Fitting with an external regressor using the forecast package

Forecast formulation:

<code>
(1 - &phi;<sub>1</sub> B - ... - &phi;<sub>p</sub> B<sup>p</sup>) (y<sup>&prime;</sup><sub>t</sub> - &mu;) = c + (1 - &theta;<sub>1</sub> B - ... - &theta;<sub>q</sub> B<sup>q</sup>) &epsilon;<sub>t</sub>
</code>

where <code>y<sup>&prime;</sup><sub>t</sub> = (1 - B)<sup>d</sup> y<sub>t</sub></code>, <code>&mu; = mean(y<sup>&prime;</sup><sub>t</sub>)</code>.


```{r}
# https://otexts.com/fpp3/regarima.html
d_train <- read.csv('d_train.csv', stringsAsFactors = FALSE)
d_test <- read.csv('d_test.csv', stringsAsFactors = FALSE)
forecast_model <- Arima(
  ts(d_train[['y']], start=d_train[['time_tick']][1]), 
  order=c(2, 0, 2), 
  xreg=ts(d_train[, c('z_0', 'x_0')], start=d_train[['time_tick']][1])
  )

forecast_model
```

Notice the recovered durable effect coefficient is way too low.


```{r}
preds <- forecast(
  forecast_model, 
  xreg=ts(d_test[, c('z_0', 'x_0')], 
  start=d_test[['time_tick']][1]))
d_test['forecast ARIMAX'] <- as.numeric(preds$mean)

# Rsquared
sse <- sum((d_test[['y']] - d_test[['forecast ARIMAX']])**2)
sey <- sum((d_test[['y']] - mean(d_test[['y']]))**2)
rsq <- 1 - sse/sey

# RMSE
rmse <- sqrt(mean((d_test[['y']] - d_test[['forecast ARIMAX']])**2))

(
  ggplot(
    data=d_test,
    mapping=aes(x=time_tick)
  )
  + geom_step(mapping=aes(y=`forecast ARIMAX`), direction='mid', color='blue')
  + geom_point(mapping=aes(y=y, shape=as.character(x_0)), size=2)
  + guides(shape = guide_legend(reverse=TRUE))
  + ggtitle(paste0(
    "forecast package on held out data, rmse: ", 
    sprintf('%.2f', rmse), ', rsq: ', sprintf('%.2f', rsq)))
) 
```


