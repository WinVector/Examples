---
title: "build versioned db"
output: html_document
date: "2024-09-19"
---


```{r}
library(DBI)
con <- dbConnect(RSQLite::SQLite(), ":memory:")
```

```{r}
# read our data
d1_orig <- read.csv(
  'Roxie_schedule_as_known_before_August.csv', 
  strip.white = TRUE, 
  stringsAsFactors = FALSE)
d1_orig$Attendance <- d1_orig$EstimatedAttendance
d1_orig$EstimatedAttendance <- NULL
d1 <- d1_orig
# d1$Date <- as.Date(d1$Date)
d1$`_usi` <- 1337
d2_orig <- read.csv(
  'Roxie_schedule_as_known_after_August.csv', 
  strip.white = TRUE, 
  stringsAsFactors = FALSE)
d2 <- d2_orig
# d2$Date <- as.Date(d2$Date)
d2$`_usi` <- 1338
d <- rbind(d1, d2)
```

```{r}
dbWriteTable(con, 'd_raw', d, overwrite=TRUE)
```

```{r}
# scan data getting newest version of each unique record
# using the fact we know that only attendance changed
# updates from external snapshots with few constraints would be harder
res <- dbGetQuery(con, "
WITH 
fact_id_scan AS (
   SELECT
     Date,
     Time,
     Movie,
     87776 + SUM(1) OVER(ORDER BY Date, Time, Movie) AS _fi
   FROM 
     d_raw
   GROUP BY
     Date,
     Time,
     Movie
),
usi_scan AS (
   SELECT
     MIN(_usi) AS _usi,
     Date,
     Time,
     Movie,
     Attendance
   FROM 
     d_raw
   GROUP BY
     Date,
     Time,
     Movie,
     Attendance
)
SELECT
    fact_id_scan._fi AS _fi,
    usi_scan.*
  FROM 
    usi_scan
  LEFT JOIN
    fact_id_scan
  ON
    usi_scan.Date = fact_id_scan.Date
    AND usi_scan.Time = fact_id_scan.Time
    AND usi_scan.Movie = fact_id_scan.Movie
  ORDER BY
     usi_scan.Date,
     usi_scan.Time,
     usi_scan.Movie,
     fact_id_scan._fi,
     usi_scan._usi,
     usi_scan.Attendance
")
```

```{r}
dbWriteTable(con, 'd_data_log', res, overwrite=TRUE)
head(dbGetQuery(con, "SELECT * from d_data_log"))
```

```{r}
update_log <- data.frame(
  `_usi` = c(1336, 1337, 1338),
  `_update_time` = c('2024-06-12 18:45:15Z', '2024-08-02 23:45:15Z', '2024-09-01 22:12:00Z'),
  `_is_redaction` = c(TRUE, FALSE, FALSE),
  note = c('PII audit', 'after July 2024 data refresh', 'after August 2024 data refresh'),
  check.names = FALSE
)
dbWriteTable(con, 'update_log', update_log, overwrite=TRUE)
head(dbGetQuery(con, "SELECT * from update_log"))
```

```{r}
d_row_deletions <- data.frame(
  `_fi` = c(3312),
  `_usi` = c(1212),
  `support staff` = c('Data PII audit'),
  check.names = FALSE
)
dbWriteTable(con, 'd_row_deletions', d_row_deletions, overwrite=TRUE)
head(dbGetQuery(con, "SELECT * from d_row_deletions"))
```


```{r}

pull_data_by_usi <- function(target_usi) {
  return (dbGetQuery(con, gsub("{target_usi}", target_usi, "
WITH 
usi_scan AS (
   SELECT
     _fi,
     MAX(_usi) AS _usi
   FROM 
     d_data_log
   WHERE
     _usi <= {target_usi}
   GROUP BY
     _fi
),
del_scan AS (
   SELECT
     _fi
   FROM 
     d_row_deletions
   WHERE
     _usi <= {target_usi}
   GROUP BY
     _fi
),
chosen_ids AS (
  SELECT
    usi_scan.*,
    del_scan._fi AS _deleted_fi
  FROM
    usi_scan
  LEFT JOIN
    del_scan
  ON
    usi_scan._fi = del_scan._fi
)
SELECT
   d_data_log.*
FROM
   d_data_log
INNER JOIN
   chosen_ids
ON
  d_data_log._fi = chosen_ids._fi
  AND d_data_log._usi = chosen_ids._usi
WHERE
   chosen_ids._deleted_fi is NULL
ORDER BY
   d_data_log._fi,
   d_data_log._usi
", fixed = TRUE)))
}
```


```{r}
d1_view <- pull_data_by_usi(1337)

head(d1_view)
```


```{r}
d2_view <- pull_data_by_usi(1338)

head(d2_view)
```


```{r}
# confirm equivalent
equivalent_data_frames <- function(a, b) {
  if(!(all(dim(a) == dim(b)))) {
    return(FALSE)
  }
  cols <- sort(colnames(a))
  if(!all(cols == sort(colnames(b)))) {
    return(FALSE)
  }
  a <- a[, cols, drop=FALSE]
  b <- b[, cols, drop=FALSE]
  a <- a[do.call(order, a), , drop = FALSE]
  b <- b[do.call(order, b), , drop = FALSE]
  return(all(a==b))
}
```

```{r}
orig_cols = c('Date', 'Time', 'Movie', 'Attendance')
stopifnot(equivalent_data_frames(d1_orig, d1_view[ , orig_cols]))
stopifnot(equivalent_data_frames(d2_orig, d2_view[ , orig_cols]))
```


```{r}
dbDisconnect(con)
```

